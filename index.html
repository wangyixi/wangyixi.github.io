<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="yixi&#39;blog">
<meta property="og:url" content="http://c2h4.ink/index.html">
<meta property="og:site_name" content="yixi&#39;blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="C2H4">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://c2h4.ink/"/>





  <title>yixi'blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">yixi'blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://c2h4.ink/2020/03/13/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="C2H4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yixi'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/13/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" itemprop="url">JS数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-13T10:07:40+08:00">
                2020-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p>基本类型可以想象成C/C++中的值类型，所谓“基本类型本身的值不会改变”，指的是基本类型在赋值过程中对原始值进行了复制，改变的是基本类型所赋值的变量。基本类型由栈自动分配内存，系统自动回收。</p>
<p>简单数据类型：<code>string</code>, <code>number</code>, <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>Symbol</code>(SE6)</p>
<p>复杂数据类型：<code>object</code></p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用类型又可以称为对象，它们在赋值时，被赋值的变量和原来的变量都引用了（指向了）同一个对象。对象在堆中动态分配内存，需要垃圾回收。</p>
<p>引用类型（对象）：<code>String</code>, <code>Number</code>, <code>Boolean</code>, <code>Object</code>, <code>Function</code>, <code>Array</code>, <code>Data</code>, <code>RegExp</code>, <code>Error</code></p>
<p>可以用以上引用类型创建相应的实例，并添加属性和方法。</p>
<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><p>首先明确的是，JS是大小写敏感的，那么上文的 <code>number</code> 和 <code>Number</code> 当然就不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; <span class="comment">//基本类型number</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="number">1</span>); <span class="comment">//与上面等价</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>); <span class="comment">//引用类型Number，是原型对象，创建一个叫c的实例</span></span><br></pre></td></tr></table></figure>

<p><img src="D:%5Cwangyixi.github.io%5Csource%5Cimage%5C1584067175515.png" alt="1584067175515"></p>
<p>使用 <code>typeof</code> 查看变量的类型，可以看到c是一个<code>object</code>，它自动带有一个 <code>__proto__</code> 属性指向对象原型对象 <code>Number</code></p>
<p><img src="D:%5Cwangyixi.github.io%5Csource%5Cimage%5C1584067447134.png" alt="1584067447134"></p>
<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p><code>typeof</code>操作可以返回以下字符串：</p>
<p><code>undefined</code> <code>boolean</code> <code>number</code> <code>string</code> <code>object</code> <code>function</code></p>
<p><code>null</code>会被理解成一个空对象。</p>
<p>函数<code>function</code>在JS中事实上也是一种对象，使用<code>typeof</code>区分的是函数和其他对象。</p>
<p>对于 <code>Number</code> 来说，使用 <code>Number()</code>创建的为 <code>number</code>类型，使用 <code>new NUmber()</code>构造函数创建的是对象，<code>typeof</code>操作符对函数名 <code>Number</code>返回的为 <code>function</code> , 由上文a,b的类型可知，<code>Number(1)</code>与1等价，所以返回的是 <code>number</code>。</p>
<p>正则 <code>RefExp</code>创建的变量数据类型则是<code>object</code> 。</p>
<p><img src="D:%5Cwangyixi.github.io%5Csource%5Cimage%5C1584069399857.png" alt="， 1584069399857"></p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p><code>typeof</code>操作符对未初始化和未声明的变量都会返回<code>undefined</code>值。</p>
<p>为了避免无法区分未初始化和未声明的变量，我们可以显式地对变量进行初始化。如果定义的变量准备将来用于保存对象，可以初始化为 <code>null</code>。</p>
<p><code>undefined</code> 值派生于 <code>null</code></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h2><p>函数<code>Number()</code> <code>parseInt()</code> <code>parseFloat()</code>可以将非数值转换成数值</p>
<h2 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h2><p>除了 <code>null</code> 和 <code>undefined</code>，其他值（包括字符串）都有 <code>toString()</code>方法，该方法返回字符串的的一个副本。</p>
<p>在将数值转换成字符串时，可以传递一个参数指定基数。</p>
<h2 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h2><p>对象有一个 <code>valueof()</code> 方法，可以返回对象的字符串、数值或布尔值表示，通常与 <code>toString()</code>返回值相同。在将对象转换成数值时，先调用 <code>valueof</code>方法，如果返回 <code>NaN</code>，则调用 <code>toString()</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://c2h4.ink/2020/03/13/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="C2H4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yixi'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/13/%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/" itemprop="url">原型和原型链</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-13T09:57:16+08:00">
                2020-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先明确一点的是，原型和原型链是针对对象的。</p>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p><strong><code>__proto__</code></strong> 是所有<strong>原型对象或对象实例</strong>自带的隐式<strong>属性</strong>，该属性指向它的原型对象。最终所有对象的原型对象为 <code>object</code>， <code>object</code>的 <code>__proto__</code>指向 <code>null</code>。</p>
<p>原型对象和对象实例不同，对象实例可以自己通过原型对象进行创建，而原型对象是JS的对象类型。</p>
<p><strong><code>prototype</code></strong>是所有<strong>函数</strong>在定义时自动创建的<strong>对象</strong>。在通过原型对象创建对象实例时，原型对象的构造函数拥有一个 <code>prototype</code> 对象，这个 <code>prototype</code> 对象则为该原型对象。</p>
<p>举例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure>

<p>a为 <code>String</code> 的实例，它有一个 <code>a.__proto__</code>属性指向它的原型对象，那么它的原型对象要怎么得知呢？通过a创建时的构造函数 <code>String()</code>，这个构造函数是原型对象的构造函数，它自带一个 <code>String.prototype</code>对象，这个对象就是原型对象 <code>String</code>。</p>
<p>在这个语句执行时，完成 <code>a.__proto__ = String.prototype</code> 的赋值，这样就可以得知对象实例a的原型对象为 <code>String</code>了。</p>
<p>对于<strong>自定义函数</strong>的 <strong><code>prototype</code>对象</strong>，这个<strong>对象</strong>会拥有一个 <strong><code>__proto__</code> 属性</strong>。这个 <strong><code>__proto__</code> 属性</strong>指向它的构造函数的<strong><code>prototype</code></strong>对象 （此时完成了一个循环有没有…我觉得这就是原型之所以很绕的原因）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">	&#x2F;*code*&#x2F;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么<strong>自定义函数a</strong>的 <strong><code>prototype</code>对象</strong>的构造函数是谁呢？ </p>
<p>在这个语句执行时，完成<code>a.prototype.__proto__ = Object.prototype</code>的赋值。</p>
<p>也就是说，函数的原型对象为 <code>Object</code>。</p>
<p>JavaScript中所有的对象（函数也是对象）都是<code>Object</code>的实例，并继承<code>Object.prototype</code>的属性和方法。</p>
<h2 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h2><p><code>a.__proto__ = String.prototype = String</code></p>
<p><code>String.prototype.constructor = String</code></p>
<p><img src="D:%5Cwangyixi.github.io%5Csource%5Cimage%5Cimage-20200313144351908.png" alt="image-20200313144351908"></p>
<h2 id="JS-new一个对象的过程"><a href="#JS-new一个对象的过程" class="headerlink" title="JS new一个对象的过程"></a>JS new一个对象的过程</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mother</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">	<span class="comment">/*code*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Mother(args);</span><br></pre></td></tr></table></figure>

<p>1.创建新对象</p>
<p><code>var son = new Mother(args);</code></p>
<p>2.新对象执行[[prototype]]连接</p>
<p><code>son.__proto__ = Mother.prototype</code></p>
<p><code>Mother</code>作为一个自定义函数，有<code>Mother.prototype.__proto__ = Object.prototype</code></p>
<p>3.新对象和函数调用的this绑定</p>
<p>相当于执行 <code>Mother.call(son, args)</code></p>
<p>4.执行构造函数中的代码</p>
<p>5.如果函数没有返回值，那么会自动返回这个新对象，<code>son</code>获得返回值，即经过构造函数处理后的新对象。</p>
<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>在上例new一个对象的过程中，存在原型链：</p>
<p><code>son.__proto__ = Mother.prototype</code></p>
<p><code>Mother.prototype.__proto__ = Object.prototype</code></p>
<p>即：</p>
<p><code>son.__proto__.proto__ = Object.prototype</code></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="判断一个对象是否为数组："><a href="#判断一个对象是否为数组：" class="headerlink" title="判断一个对象是否为数组："></a>判断一个对象是否为数组：</h3><ol>
<li>使用 <code>instanceof</code> 操作符</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>通过查找左操作数 <code>arr</code> 的原型链上是否有右操作数 <code>Array</code> 构造函数的原型对象</p>
<p><code>arr.__proto__ = Array.prototype</code></p>
<ol start="2">
<li><code>Array.isArray()</code></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://c2h4.ink/2020/03/01/HTML-CSS-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="C2H4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yixi'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/01/HTML-CSS-%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/" itemprop="url">HTML-CSS-笔记（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-01T10:47:55+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-内联元素与块级元素"><a href="#1-内联元素与块级元素" class="headerlink" title="1.内联元素与块级元素"></a>1.内联元素与块级元素</h1><table>
<thead>
<tr>
<th align="center">区别</th>
<th align="center">内联元素</th>
<th align="center">块级元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">排列方式</td>
<td align="center">不会独占一行，相邻的内联元素排在同一行，宽度随内容变化</td>
<td align="center">会独占一行，默认情况下宽度自动填满父元素宽度</td>
</tr>
<tr>
<td align="center">宽高设置</td>
<td align="center">不可以设置宽度width和高度height</td>
<td align="center">可以设置宽度width和高度height</td>
</tr>
<tr>
<td align="center">边距设置</td>
<td align="center">可以设置margin, padding，但只在水平方向有效</td>
<td align="center">可以设置margin, padding</td>
</tr>
</tbody></table>
<h2 id="常见内联元素："><a href="#常见内联元素：" class="headerlink" title="常见内联元素："></a>常见内联元素：</h2><p><strong>a – 锚点</strong><br>abbr – 缩写<br>b – 粗体(不推荐)<br>big – 大字体<br><strong>br – 换行</strong><br>cite – 引用<br><strong>code – 计算机代码(在引用源码的时候需要)</strong><br><strong>em – 强调</strong><br>font – 字体设定(不推荐)<br>i – 斜体<br>kbd – 定义键盘文本<br><strong>label – 表格标签</strong><br><strong>q – 短引用</strong><br><strong>span – 常用内联容器，定义文本内区块</strong><br><strong>strong – 粗体强调</strong><br><strong>textarea – 多行文本输入框</strong> </p>
<h2 id="常见块级元素"><a href="#常见块级元素" class="headerlink" title="常见块级元素"></a>常见块级元素</h2><p><strong>address – 地址</strong><br><strong>blockquote – 块引用</strong><br>dir – 目录列表<br><strong>div – 常用块级元素，也是CSS layout的主要标签</strong><br><strong>dl – 定义列表</strong><br>fieldset – form控制组<br><strong>form – 交互表单</strong><br><strong>h1 – h6 标题</strong><br><strong>hr – 水平分隔线</strong><br>menu – 菜单列表<br><strong>ol – 有序表单</strong><br><strong>p – 段落</strong><br>pre – 格式化文本<br><strong>table – 表格</strong><br><strong>ul – 无序列表</strong><br><strong>li – 列表项目</strong></p>
<h2 id="内联块状元素inline-block"><a href="#内联块状元素inline-block" class="headerlink" title="内联块状元素inline-block"></a>内联块状元素inline-block</h2><p>设置<code>display:inline-block</code></p>
<p>img</p>
<p>input</p>
<p>button</p>
<p>呈现出inline对象，可以与其它行内元素并排，同时也可以设置宽高和边距。</p>
<h2 id="内联元素与块级元素的转换"><a href="#内联元素与块级元素的转换" class="headerlink" title="内联元素与块级元素的转换"></a>内联元素与块级元素的转换</h2><p>转内联元素：</p>
<p><code>display: inline</code></p>
<p>转块级元素：</p>
<p><code>display: block</code></p>
<h3 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h3><p><code>&lt;p&gt;</code>是块元素，但是不能包含除了它本身之后其他的块元素</p>
<p><code>&lt;a&gt;</code>是内联元素，但是可以包含除了它本身之后的任意块元素</p>
<h1 id="2-position属性"><a href="#2-position属性" class="headerlink" title="2.position属性"></a>2.position属性</h1><h2 id="无定位"><a href="#无定位" class="headerlink" title="无定位"></a>无定位</h2><p><code>position: static</code></p>
<p>该属性值为所有元素定位的默认情况。在我们不愿意元素继承父元素<code>position</code>属性时，可以使用<code>position:static</code>取消继承，即还原元素定位的默认值。元素出现在正常的文档流中。</p>
<p>此时 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性和z-<code>index</code>声明无效。</p>
<h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p><code>position: absolute</code></p>
<p>元素完全脱离文档流，可以设置<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性和z-<code>index</code>，其参考对象时离该元素最近的<code>position</code>值不是<code>static</code>的父元素，当其父元素<code>position</code>值均为<code>static</code>或者未定义时，其参考对象应该是<code>document</code>（浏览器视窗大小的矩形）。一般与相对定位配合使用，父元素为相对定位，子元素设置绝对定位使其相对父元素偏移。</p>
<p>改变内联元素的特性：使内联元素在设置宽高的时候支持宽高</p>
<p>改变区块元素的特性：使区块元素在未设置宽度时由内容撑开宽度</p>
<h2 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h2><p><code>position: relative</code></p>
<p>元素不脱离文档流，可以设置<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性和z-<code>index</code>，其参考对象为离该元素最近的父元素，相对于自身原本位置进行偏移。</p>
<p>不影响内联元素和区块元素特性。</p>
<h2 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h2><p><code>position: fixed</code></p>
<p>相对于浏览器窗口进行定位。可以设置<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 属性和<code>z-index</code>。</p>
<p>兼容性问题：IE6不支持。</p>
<h1 id="浮动元素的定位"><a href="#浮动元素的定位" class="headerlink" title="浮动元素的定位"></a>浮动元素的定位</h1><ul>
<li>只有横向浮动，没有纵向浮动</li>
<li>脱离文档流，其父元素将得不到脱离普通流的子元素高度</li>
<li>会将元素的 <code>display</code> 属性变成 <code>block</code></li>
<li>浮动元素的后一个元素会围绕着浮动元素（文字围绕图片），不会遮盖后一个元素</li>
<li>对前一个元素没有任何影响</li>
<li>同时应用 <code>position: absolute</code>和 <code>float</code>属性时，<code>float</code>失效</li>
<li>块级元素于浮动元素重叠，处于浮动元素之下；行内元素相反</li>
</ul>
<h1 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h1><p>默认<code>floar: none;</code>，可以设置向左或向右浮动<code>float: left;</code>或<code>float: right;</code></p>
<p>当一个盒子里的元素全为浮动且盒子本身没有高度时，浮动的子元素的高不会撑开盒子，盒子变成了一条线。</p>
<h2 id="额外标签法"><a href="#额外标签法" class="headerlink" title="额外标签法"></a>额外标签法</h2><p>给最后一个浮动元素后添加一个空标签，设置<code>clear: both;</code></p>
<p>如：<code>&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;</code></p>
<p>或  <code>&lt;hr class=&quot;clear&quot;/&gt;</code></p>
<p>缺点：添加无意义标签，语义差</p>
<h2 id="父级添加overflow属性"><a href="#父级添加overflow属性" class="headerlink" title="父级添加overflow属性"></a>父级添加overflow属性</h2><p><code>overflow: hidden;</code> 或 <code>overflow: auto;</code></p>
<p>IE6中还需添加<code>zoom: 1</code>或为父容器设置宽高</p>
<p><code>overflow</code>属性的参数：</p>
<ul>
<li>scroll：一定会出现滚动条</li>
<li>auto：子元素内容大于父元素时出现滚动条</li>
<li>visible：溢出的内容出现在父元素之外</li>
<li>hidden：溢出隐藏</li>
</ul>
<h2 id="after伪元素"><a href="#after伪元素" class="headerlink" title="after伪元素"></a>after伪元素</h2><p>给父元素添加<code>clearfix</code>类</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;<span class="comment">/*伪元素是行内元素 正常浏览器清除浮动方法*/</span></span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">    *zoom: 1;/*ie6清除浮动的方式 *号只有IE6-IE7执行，其他浏览器不执行*/</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>缺点：IE6、7不支持伪元素<code>after</code></p>
<h1 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h1><p><code>border: none</code> 表示无边框样式，浏览器并不会对边框进行渲染，也没有实际的宽度。</p>
<p><code>border: 0</code> 设置边框的宽度为0，浏览器对边框进行渲染。</p>
<p><code>border-style</code>应在<code>border-color</code>之前设置</p>
<h1 id="回流reflow和重绘repaint"><a href="#回流reflow和重绘repaint" class="headerlink" title="回流reflow和重绘repaint"></a>回流reflow和重绘repaint</h1><p><code>dispaly: none</code> 不为被隐藏的对象保留其物理空间。会触发<code>reflow</code>回流。</p>
<p><code>visibility: hidden</code> 所占据的空间位置仍然存在，仅为视觉上的完全透明。会触发<code>repaint</code>重绘。</p>
<h2 id="reflow"><a href="#reflow" class="headerlink" title="reflow"></a>reflow</h2><p>某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。</p>
<p>触发<code>reflow</code>的情况</p>
<p>1：改变窗口大小<code>resize</code>或<code>scroll</code>页面</p>
<p>2：改变文字大小或更换字体</p>
<p>3：内容的改变，如用户在输入框中敲字</p>
<p>4：激活伪类，如:<code>hover</code></p>
<p>5：CSS3 动画(<code>animation</code>)和过渡(<code>transition</code>)，动画的每一<code>frame</code>都会触发<code>reflow</code>；</p>
<p>6：JS脚本操作<code>DOM</code>元素。即添加(<code>appendChild</code>)、删除(<code>removeChild</code>)<code>DOM</code>元素或者改变<code>DOM</code>元素的可见性(<code>display:none</code>)</p>
<p>7：修改<code>width</code>/<code>height</code>/<code>border</code>/<code>margin</code>/<code>padding</code>和读取<code>offsetWidth</code>/<code>Height</code>、<code>offsetLeft</code>/<code>Top</code>、<code>scrollTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>、<code>clientTop</code>/<code>Left</code>/<code>Width</code>/<code>Height</code>等属性时。因为有些元素依赖这些属性去计算。</p>
<p>8：设置<code>style</code>属性（所以最好用<code>class</code>而不是直接设置<code>style</code>）</p>
<h2 id="repaint"><a href="#repaint" class="headerlink" title="repaint"></a>repaint</h2><p>改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 <code>repaint</code>（重绘）。<code>repaint</code> 的速度明显快于 <code>reflow</code>。</p>
<p>只涉及视觉效果，不涉及布局。</p>
<p>触发<code>repaint</code>的情况</p>
<ol>
<li><code>color</code>的修改</li>
<li><code>text-align</code>的修改，如 <code>text-align：center；</code></li>
<li><code>a:hover</code>也会造成重绘；</li>
<li><code>:hover</code>引起的颜色等不导致页面回流的<code>style</code>变动；等等。</li>
</ol>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol>
<li>尽量通过<code>class</code>来设计元素样式，不用<code>style</code></li>
<li>尽可能修改层级较低的<code>DOM</code>结点</li>
<li>不要把 <code>DOM</code> 节点的属性值放在一个循环里当成循环里的变量。不然这会导致大量地读写这个结点的属性。</li>
<li>把 <code>DOM</code> 离线后修改。如：<br><code>a&gt;</code> 使用 <code>documentFragment</code> 对象在内存里操作 <code>DOM</code>。<br><code>b&gt;</code> 先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>repaint</code>)，然后你想怎么改就怎么改。比如修改 <code>100</code> 次，然后再把他显示出来。<br><code>c&gt;</code> <code>clone</code> 一个 <code>DOM</code> 节点到内存里，然后想怎么改就怎么改，改完后，和在线的那个的交换一下。</li>
<li>为有动画的元素使用<code>fixed</code>或<code>absolute</code>的<code>position</code>，使动画元素从<code>DOM</code>中独立出来，从而减少对其他元素的影响，那么修改他们的<code>CSS</code>可以减少<code>reflow</code></li>
<li>不要使用<code>table</code>布局。table的每个元素的大小以及内容的改动，都会导致整个<code>table</code>进行重新计算，造成大幅度的<code>repaint</code>或者<code>reflow</code>。改用<code>div</code>则可以进行针对性的<code>repaint</code>和避免不必要的<code>reflow</code></li>
<li><code>CSS</code>中避免使用计算表达式</li>
</ol>
<h1 id="默认边距"><a href="#默认边距" class="headerlink" title="默认边距"></a>默认边距</h1><table>
<thead>
<tr>
<th></th>
<th>margin</th>
<th>padding</th>
</tr>
</thead>
<tbody><tr>
<td>h1~h6</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>dl</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>dd</td>
<td>有（margin-left）</td>
<td>无</td>
</tr>
<tr>
<td>ol, ul</td>
<td>有</td>
<td>有（padding-left）</td>
</tr>
<tr>
<td>table</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>th, td</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>form</td>
<td>有（除IE8）</td>
<td>无</td>
</tr>
<tr>
<td>p</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>textarea</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>select</td>
<td>无</td>
<td>有（chrome, safari）</td>
</tr>
<tr>
<td>img</td>
<td>有</td>
<td>无</td>
</tr>
<tr>
<td>body</td>
<td>有</td>
<td>无</td>
</tr>
</tbody></table>
<h1 id="lt-a-gt-标签不跳转的方法"><a href="#lt-a-gt-标签不跳转的方法" class="headerlink" title="&lt;a&gt;标签不跳转的方法"></a><code>&lt;a&gt;</code>标签不跳转的方法</h1><ul>
<li><code>onclick</code>事件返回 <code>false</code></li>
</ul>
<p><code>&lt;a href=&quot;...&quot; onclick=&quot;return false&quot;&gt;&lt;/a&gt;</code></p>
<ul>
<li>伪协议</li>
</ul>
<p><code>&lt;a href=&quot;javascript:void(0)&quot;&gt;&lt;/a&gt;</code></p>
<ul>
<li>使用<code>(#)</code></li>
</ul>
<p><code>&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</code></p>
<p>#默认为当前页面</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://c2h4.ink/2018/12/23/webpack%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="C2H4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yixi'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/23/webpack%E5%85%A5%E9%97%A8/" itemprop="url">webpack入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-23T15:31:16+08:00">
                2018-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="node-js、npm和webpack"><a href="#node-js、npm和webpack" class="headerlink" title="node.js、npm和webpack"></a><em>node.js、npm<em>和</em>webpack</em></h2><p><em>node.js</em>是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是运行在服务器端的JavaScript，可以摆脱浏览器宿主环境，解析和执行js代码，直接进行底层系统调用，并且内置提供了HTTP服务器相关的大量API。 <em>npm</em>随node.js一起安装，是一个包管理工具，用来解决node.js代码部署问题。 <em>webpack</em>是前端工程化打包工具，可以处理功能丰富的大型网站所拥有的复杂的js代码、css代码等，解析它们的依赖关系，转换和打包成模块使用，实现自动化管理前端代码。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从功能上来说，node.js可以开启一个Web服务，给浏览器提供数据去展示，并且接收浏览器提交过来的用户产生的数据，存储到数据库中，方便后面使用。 我们在代码中使用node.js打包好的模块（模块指具有相同功能的代码的集合），然后需要通过npm工具为我们的工程导入模块以便代码在本地调用，npm工具被包装成一个类似命令行的模式提供给开发者使用。除了调用node.js已有的模块，我们还可以在npm上发布自己的模块和调用其他人所发布的模块。 webpack则是运行在npm上的一个任务执行者，可以看作npm为开发者提供的一个功能，和webpack实现类似功能的主流构建工具还有grunt，gulp，browerity等，其中webpack非常适用于管理前端开发代码，它将一切文件模块化，可以方便地帮助我们简化前端复杂繁多的js文件、css文件的调用，使我们的web应用工程化。 有用的资料：<a href="https://webpack.js.org" target="_blank" rel="noopener">webpack官方网站</a></p>
<h1 id="webpack使用"><a href="#webpack使用" class="headerlink" title="webpack使用"></a><em>webpack</em>使用</h1><p>前提：本地环境支持node.js</p>
<h2 id="全局安装webpack"><a href="#全局安装webpack" class="headerlink" title="全局安装webpack"></a>全局安装webpack</h2><p><code>npm install webpack -g</code></p>
<p>全局安装webpack </p>
<p>webpack4，命令行相关的内容都移到 webpack-cli，所以还需要安装 webpack-cli </p>
<p><code>npm install webpack-cli -g</code></p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><code>mkdir app</code> </p>
<p>项目文件夹</p>
<p>在项目路径下 </p>
<p><code>npm init –yes</code></p>
<p>创建package.json文件</p>
<p>package.json 是包描述文件，存储着包的信息（包名、版本、项目的依赖项），最好每个项目都要有个 package.json 文件，就像产品说明书。此文件可自己普通文本改名的方式创建，但一般是 npm 命令创建。运行npm init命令会以向导的方式填写包的信息，不想填的话可回车略过。–yes是快速创建，可以跳过信息的填写直接创建，之后想改可以直接到package.json文件中修改。</p>
<h2 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h2><p><code>npm install webpack –save-dev</code></p>
<p>为什么全局安装了还要局部安装：<a href="https://www.cnblogs.com/linziwei/p/7786895.html" target="_blank" rel="noopener">npm全局安装和局部文件安装区别</a> 关于–save和-dev可参考：<a href="https://www.limitcode.com/detail/59a15b1a69e95702e0780249.html" target="_blank" rel="noopener">npm –save和–save-dev 傻傻分不清</a> 接下来分别示例打包js文件和非js文件(css)两种使用场景来说明webpack使用的基本步骤</p>
<h2 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h2><p>在app目录下创建test.js文件并保存</p>
<p><code>document.write(“it works!”);</code></p>
<p>打包为bundle.js </p>
<p><code>webpack test.js bundle.js</code></p>
<p>注意，如果是高版本的npm，比如我的是5.6.0，需要加-o </p>
<p><code>webpack test.js -o bundle.js</code></p>
<h2 id="CSS文件"><a href="#CSS文件" class="headerlink" title="CSS文件"></a>CSS文件</h2><p>创建style.css文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123; background: pink; &#125;</span><br></pre></td></tr></table></figure>

<p>修改test.js文件 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(“!style-loader!css-loader!./style.css”);<span class="comment">//引用style.css文件 document.write(require(“it works!”);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。</p>
</blockquote>
<p>为了使用style-loader和css-loader，同样我们也需要全局安装style-loader和css-loader </p>
<p><code>npm install style-loader css-loader -g</code></p>
<p>再局部安装 </p>
<p><code>npm install style-loader css-loader –save-dev</code></p>
<p>打包</p>
<p><code>webpack test.js -o bundle.js</code></p>
<p>浏览器打开index.html查看效果</p>
<h2 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h2><p>如果我们需要打包多个文件，那么在命令行下一个个输入文件名会比较麻烦，所以我们一般通过配置webpack.config.js文件，然后就可以直接使用webpack命令来打包所有文件。 创建webpack.config.js文件 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">	<span class="comment">//指定入口文件 </span></span><br><span class="line">    entry: &#123; <span class="attr">entry</span>: ‘./test.js’ &#125;, </span><br><span class="line">    <span class="comment">//指定出口文件 </span></span><br><span class="line">    output: &#123; <span class="attr">path</span>: __dirname, <span class="attr">filename</span>: ‘test.js’ &#125;, </span><br><span class="line">    <span class="comment">//模块,指定加载器,可配置各种加载器,test里指定加载文件的格式(.css)，loader里指定加载器名称 </span></span><br><span class="line">    <span class="built_in">module</span>:&#123; <span class="attr">rules</span>:[&#123;<span class="attr">test</span>:<span class="regexp">/\.css\$/</span>&#125;, </span><br><span class="line">    loader:”style-loader!css-loader”] </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>注意，webpack2之后将loaders改为了rules，如果还是写成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaders:[&#123;<span class="attr">test</span>:<span class="regexp">/\.css\$/</span>&#125;, <span class="attr">loader</span>:”style-loader!css-loader”]</span><br></pre></td></tr></table></figure>

<p>将报错</p>
<p>在指定出口文件中，<code>path:__dirname</code>path指生成的出口文件的统一路径，__dirname表示当前目录。</p>
<p>如果需要生成的文件在别的目录下，可以在文件开始引入模块path</p>
<p><code>const path=require(‘path’);</code></p>
<p>然后就可以使用path.join()方法，这种方法将多个参数字符串合并成一个路径字符串</p>
<p><code>path: path.join(__dirname,’dist’)</code></p>
<p>出口文件会在/app/dist文件夹下，如果没有dist文件夹会自动创建</p>
<p>或者path.resolve()方法，这种方法以程序为根目录，作为起点，根据参数解析出一个绝对路径</p>
<p><code>path: path.resolve(__dirname,’./dist’)</code></p>
<p>关于它们的区别：<a href="https://blog.csdn.net/qq_33745501/article/details/80270708" target="_blank" rel="noopener">path.join()和path.resolve()</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://c2h4.ink/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="C2H4">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="yixi'blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/" itemprop="url">使用LEX(flex)和YACC(bison)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T11:49:00+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="LEX与YACC介绍"><a href="#LEX与YACC介绍" class="headerlink" title="LEX与YACC介绍"></a><em>LEX</em>与<em>YACC</em>介绍</h1><p>Lex(Lexxical Analyzar)和Yacc(Yet Another Compiler)分别是词法解析器和语法解析器，用目标语言的正则表达式编写Lex代码，经过flex编译可以生成词法分析的C代码，用目标语言的BNF编写Yacc代码，经过bison编译可以生成语法分析的C代码，将词法分析和语法分析的C代码一起编译即可生成目标语言的编译器。 Lex和Yacc原本是Unix/Linux系统下的工具，UnxUtils将他们移植到了 Windows平台。具体安装配置步骤可以参考：<a href="https://blog.csdn.net/XiaoPANGXia/article/details/44132693" target="_blank" rel="noopener">lex和yacc安装配置</a>）。</p>
<h1 id="环境和工具"><a href="#环境和工具" class="headerlink" title="环境和工具"></a>环境和工具</h1><ul>
<li>Windows</li>
<li>lex和yacc</li>
<li>gcc编译器</li>
<li>PowerShell/cmd或IDE+ParserGenerator (推荐直接使用命令行编译，我没用IDE配置过)</li>
</ul>
<h1 id="Lex使用"><a href="#Lex使用" class="headerlink" title="Lex使用"></a>Lex使用</h1><p>一个基本的lex.l程序 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%&#123; #include &#x2F;第一部分&#x2F; %&#125; </span><br><span class="line">&#x2F;第二部分&#x2F; %% </span><br><span class="line">&#x2F;第三部分&#x2F; %% </span><br><span class="line">&#x2F;第四部分&#x2F; </span><br><span class="line">void main() &#123; </span><br><span class="line">    printf(“The first Lex program.\n”);</span><br><span class="line">&#125; </span><br><span class="line">int yywrap(void) &#123;</span><br><span class="line">    return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>保存为lex.l文件 在保存文件目录下打开命令行 </p>
<p><code>flex lex.l</code></p>
<p>会编译生成lex.yy.c文件 编译lex.yy.c </p>
<p><code>lex.yy.c</code></p>
<p>会编译生成a.exe可执行文件 运行a.exe文件即可看到输出。</p>
<h1 id="Lex语法规则"><a href="#Lex语法规则" class="headerlink" title="Lex语法规则"></a>Lex语法规则</h1><p>lex代码被我分为四个部分</p>
<ul>
<li>第一部分 - 定义</li>
</ul>
<p>包含在<code>%{/*第一部分*/%}</code>，这个部分用来发需要用到的头文件、全局变量、函数说明等，这一部分内容会全部一模一样的拷贝到lex.yy.x文件中。</p>
<ul>
<li>第二部分 - 正规定义</li>
</ul>
<p>这部分可以为一些词法规则进行简化定义，方便使用。 如：<code>[A-Za-z]</code>  之后就可以直接用letter代替正则式[A-Za-z]出现</p>
<ul>
<li>第三部分-词法规则</li>
</ul>
<p>这部分为Lex模式匹配，也是lex代码的重点书写部分。列出词法分析器所需要匹配的正则表达式（或其在第二部分定义的简称），及其在匹配到该正规式时需要进行的动作。 如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;printf(“whitespace\n”);&#125;</span><br><span class="line">&#123;printf(“linebreak\n”);&#125; </span><br><span class="line">“int” &#123;printf(“INT\n”)&#125;; </span><br><span class="line">“&#x3D;” &#123;printf(“colon\n”);&#125; </span><br><span class="line">&#123;letter&#125; </span><br><span class="line">&#123;printf(“ID\n”);&#125;</span><br></pre></td></tr></table></figure>

<p>每一行一条规则，规则前半部分时正规式或简称，注意若是匹配字符串则需要用双引号包含，若使用第二部分定义的简称需要用{}包含。后半部分用空格和前半部分用空格隔开，用{}包含，编写匹配到了该词法是程序需要执行的步骤，完全遵照C语言语法，例子中是匹配成功输出相应提示信息。</p>
<ul>
<li>第四部分 - 辅助函数段</li>
</ul>
<p>这一部分也是用C语言语法，内容也会全部原原本本地拷贝lex.yy.c函数中。在使用中我定义了<code>yywrap()</code> 的函数，这是为了兼容flex版本&gt;2.5.4，除了定义该函数，也可以在文件首行写<code>%option noyywrap</code>，否则编译lex.yy.c时会出现<code>undefined reference toyywrap</code>的错误。具体可参考：<a href="https://stackoverflow.com/questions/1811125/undefined-reference-to-yywrap" target="_blank" rel="noopener">Undefined Reference To yywrap - stackoverflow</a> </p>
<h1 id="Yacc使用"><a href="#Yacc使用" class="headerlink" title="Yacc使用"></a>Yacc使用</h1><p>一个基本的yacc.y程序 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123; <span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*第一部分*/</span> %&#125; </span></span><br><span class="line"><span class="comment">/*第二部分*/</span> %token ID %% </span><br><span class="line"><span class="comment">/*第三部分*/</span> definition: INT ID | ID ; %% </span><br><span class="line"><span class="comment">/*第四部分*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">char</span> * msg)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(“\nerror:%s\n”,msg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译yacc.y文件 <code>bison yacc.y</code> 生成yacc.tab.c文件</p>
<h1 id="Yacc语法"><a href="#Yacc语法" class="headerlink" title="Yacc语法"></a>Yacc语法</h1><p>要生成最终的语法编译器，需要词法分析器的配合，所以yacc的语法结合lex程序一起分析。</p>
<ul>
<li>第一部分</li>
</ul>
<p>与lex相同</p>
<ul>
<li>第二部分</li>
</ul>
<p>说明语法规则中需要用到的所有终结符和定义算符优先级和结合性等。 具体如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%start &#x2F;&#x2F;语法开始符 </span><br><span class="line">%token &#x2F;&#x2F;终结符 </span><br><span class="line">%left &#x2F;&#x2F;左结合性 </span><br><span class="line">%right &#x2F;&#x2F;右结合性 </span><br><span class="line">%nonassoc &#x2F;&#x2F;无结合性 </span><br><span class="line">%type &#x2F;&#x2F;非终结符语义类型 </span><br><span class="line">%union &#x2F;&#x2F;语义值类型说明</span><br></pre></td></tr></table></figure>

<p><code>%start</code> 后接的是上下文无关文法的开始符号，它是一个特殊的非终结符，所有的推导都从这个非终结符开始。如果不说明%start，yacc自动将语法规则部分（第三部分）中第一条语法规则左部的非终结符作为语法开始符。 <code>%token</code>所接的是终结符，也就是词法分析器中匹配的元素，我们首先要在lex.l中的词法匹配中返回终结符的名称，才能在yacc.y中使用这个非终结符。 举个例子 在lex.l第三部分中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%% [A-Za-z]+ &#123;printf(“ID\n”);return (ID);&#125; %%</span><br></pre></td></tr></table></figure>

<p> 返回名称为ID的终结符 在yacc.y第二部分中： [cc]%token ID 如果有多个非终结符，可以换行，也可以写在同一行<code>%token ID NUM</code> <code>%token ID %token NUM</code>  <code>%left</code> <code>%right</code> <code>%nonassoc</code>后接需要定义优先级的算符，定义在越后排优先级越高，<code>%nonassoc</code>需要对应<code>%prec</code>使用，<code>%prec</code>使用在语法规则中。 举个例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*第二部分*&#x2F; %token ID %left ‘+’ ‘-‘ %left ‘*‘ %nonassoc UMINUS %% </span><br><span class="line">&#x2F;*第三部分*&#x2F; term: ‘-‘ term %prec | term ‘*‘ ID | term ‘+’ ID | term ‘-‘ ID ; %%</span><br></pre></td></tr></table></figure>

<p> 就可以定义’<em>‘优先级大于’+’和’-‘，但首项可以带符号’-‘，首项的符号优先级大于因子的算符。 比如1-2\</em>3的计算是1-(2<em>3)，但-1</em>2的计算是(-1)<em>2而不是-(1</em>2)。</p>
<h3 id="区分左结合性和右结合性"><a href="#区分左结合性和右结合性" class="headerlink" title="区分左结合性和右结合性"></a>区分左结合性和右结合性</h3><p>文法1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term : term+factor |factor</span><br></pre></td></tr></table></figure>

<p> 文法2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term : factor+term |factor</span><br></pre></td></tr></table></figure>

<p>文法1中‘+’是左结合的，文法2中‘+’是右结合的。 文法1中<code>term = ( term + factor1) + factor2</code>是符合的，其中factor1和前一个+号结合，所以该运算符‘+’是左结合的 文法2中<code>term = factor1 + ( factor2 + term)</code>是符合的，其中factor2和后一个+号结合，所以该运算符‘+’是右结合的 除了算符可以定义优先级，我们也可以利用优先级来定义语法的关键字。 比如在S语言中，有var, const, if, while等关键字，它们同样也符合变量的词法定义<code>{A-Za-z}({A-Za-z}|{0-9})*</code>，在语法分析中就会被识别成变量而导致分析错误，但如果把这些关键字的优先级设置为高于变量，这样在语法分析中就会优先被识别为关键字。注意它们应该都是右结合性，原因参考上面写的优先级判别。 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%right ID %right CONST VAR IF ELSE THEN WHILE DO BEGIN END</span><br></pre></td></tr></table></figure>



<ul>
<li>第三部分</li>
</ul>
<p>这部分写语言的BNF范式，冒号:的左边即BNF范式的左边，冒号右边即BNF范式的右边，多个推导用|分隔，最后要用分号;结尾。每项推导后面也可以用{}包含C代码，作为匹配到该条语法规则后想要程序进行的动作。</p>
<ul>
<li>第四部分</li>
</ul>
<p>与lex相同 值得注意的是yacc自带的一个函数yyerror </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int yyerror(char *msg) &#123; printf(“\nerror:%s\n”,msg); &#125;</span><br></pre></td></tr></table></figure>

<p>可以输出编译测试代码的错误信息。 但是要清醒一点，输出的是测试代码的错误，而不是yacc代码的错误，yacc是语言编译器的编译器，以c语言举例，它编译生成的是gcc，使用gcc编译用c语言写的测试代码，输出的是测试代码的错误信息而不是gcc编译器源码的错误。有段时间我一直测试输出parse error，其实是进行测试的代码段不符合语言的语法，我非常脑子不清楚地改了半天源码= = 测试代码可以用txt文件储存 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">extern</span> FILE* yyin; yyin = fopen(“test.txt”,”r”); </span><br><span class="line">	yyparse(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中读取并分析</p>
<h1 id="生成语法分析器"><a href="#生成语法分析器" class="headerlink" title="生成语法分析器"></a>生成语法分析器</h1><p>lex.l需要引用yacc.tab.h头文件，所以还要用bison生成yacc.tab.h头文件<code>yacc -d yacc.y</code>加参数-d会生成yacc.tab.h和yacc.tab.c文件 然后编译lex.l文件生成lex.yy.c文件 <code>flex lex.l</code>编译lex.yy.c和yacc.tab.c文件 g<code>cc lex.yy.c yacc.tab.c</code> 默认生成的可执行文件是a.exe，这个可执行文件就是我们的语法编译器了。</p>
<h1 id="解决文法冲突"><a href="#解决文法冲突" class="headerlink" title="解决文法冲突"></a>解决文法冲突</h1><p>在第一次写复杂如S语言的文法，难免会出现移进/归约冲突、归约/归约冲突，还可能会定义了无用规则等错误，这些错误bison都会在我们编译yacc.y时指出来</p>
<p> 我们可以通过生成yacc.output文件来找到具体是那些文法出了错误 <code>bison -v yacc.y</code> 在yacc.output文件中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Useless nonterminals: loop_stmt Terminals which are not used: WHILE DO CASE Useless rules: #18 loop_stmt : WHILE condition DO stmt; Conflict in state 42 between rule 31 and token ‘+’ resolved as shift. Conflict in state 42 between rule 31 and token ‘*‘ resolved as shift. Conflict in state 65 between rule 17 and token ELSE resolved as shift. Conflict in state 70 between rule 29 and token ‘+’ resolved as shift. Conflict in state 70 between rule 29 and token ‘*‘ resolved as shift. Conflict in state 71 between rule 30 and token ‘+’ resolved as reduce. Conflict in state 71 between rule 30 and token ‘*‘ resolved as shift. </span><br><span class="line">State 27 contains 1 shift&#x2F;reduce conflict.</span><br><span class="line">State 43 contains 11 reduce&#x2F;reduce conflicts.</span><br></pre></td></tr></table></figure>

<p>先检查无用的非终结符和无用的规则是否忘了在文法中使用，如果不是则要删除。 状态27存在移进/归约错误 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state 27 term ; factor . ‘*‘ term (rule 34) term ; factor . ‘&#x2F;‘ term (rule 35) unary ; factor . (rule 38) ‘*‘ shift, and go to state 54 ‘&#x2F;‘ shift, and go to state 55 ‘*‘ [reduce using rule 38 (unary)] $default reduce using rule 38 (unary)</span><br></pre></td></tr></table></figure>

<p>可以看到识别到’*’时可以移进也可以归约，需要对文法进行更改。 状态43存在移进归约/归约错误，查看同移进/归约，找到相应规则后进行修改。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="S语言的BNF表示"><a href="#S语言的BNF表示" class="headerlink" title="S语言的BNF表示"></a>S语言的BNF表示</h2><p>(1) &lt;程序&gt;→[&lt;常量说明&gt;][&lt;变量说明&gt;]&lt;语句&gt; </p>
<p>(2) &lt;常量说明&gt;→Const &lt;常量定义&gt;{，&lt;常量定义&gt;}； </p>
<p>(3) &lt;常量定义&gt;→&lt;标识符&gt;＝&lt;无符号整数&gt; </p>
<p>(4) &lt;无符号整数&gt;→&lt;数字&gt;{&lt;数字&gt;} </p>
<p>(5) &lt;字母&gt;→a|b|c| … |z </p>
<p>(6) &lt;数字&gt;→0|1|2| … |9 </p>
<p>(7) &lt;标识符&gt;→&lt;字母&gt;{&lt;字母&gt;|&lt;数字&gt;} </p>
<p>(8) &lt;变量说明&gt;→Var &lt;标识符&gt;{，&lt;标识符&gt;}； </p>
<p>(9) &lt;语句&gt;→&lt;赋值语句&gt;|&lt;条件语句&gt;|&lt;当循环语句&gt;|&lt;复合语句&gt;|ε </p>
<p>(10) &lt;赋值语句&gt;→&lt;标识符&gt;＝&lt;表达式&gt;;</p>
<p> (11) &lt;表达式&gt;→[＋|－]&lt;项&gt;{&lt;加法运算符&gt;&lt;项&gt;} </p>
<p>(12) &lt;项&gt;→&lt;因子&gt;{&lt;乘法运算符&gt;&lt;因子&gt;} </p>
<p>(13) &lt;因子&gt;→&lt;标识符&gt;|&lt;无符号整数&gt;|‘(’&lt;表达式&gt;‘)’</p>
<p> (14) &lt;加法运算符&gt;→＋|－</p>
<p> (15) &lt;乘法运算符&gt;→* |／ </p>
<p>(16) &lt;条件语句&gt;→if &lt;条件&gt; then &lt;语句&gt;| if &lt;条件&gt; then &lt;语句&gt; else &lt;语句&gt; </p>
<p>(17) &lt;条件&gt;→&lt;表达式&gt;&lt;关系运算符&gt;&lt;表达式&gt; </p>
<p>(18) &lt;关系运算符&gt;→＝＝|＜＝|＜|＞|＞＝|＜＞ </p>
<p>(19) &lt;当循环语句&gt;→while &lt;条件&gt; do &lt;语句&gt; </p>
<p>(20) &lt;复合语句&gt;→begin &lt;语句&gt;{；&lt;语句&gt;} end 注：产生式中&lt;、&gt;括起的部分表示一个非终结符号，[、]括起的部分表示可 选项，{、}括起的部分表示可重复，符号 | 表示“或”。</p>
<p>一个简单文法的lex.l和yacc.y代码 文法： E→E+T | T T→T*F |F F→( E )</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">C2H4</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">C2H4</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
