<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>yixi&#39;blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="yixi&#39;blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="yixi&#39;blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="C2H4">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="yixi&#39;blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">yixi&#39;blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-webpack入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/webpack%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2018-12-23T07:31:16.000Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/webpack%E5%85%A5%E9%97%A8/">webpack入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="node-js、npm和webpack"><a href="#node-js、npm和webpack" class="headerlink" title="node.js、npm和webpack"></a><em>node.js、npm<em>和</em>webpack</em></h2><p><em>node.js</em>是一个基于 Chrome V8 引擎的 JavaScript 运行环境，是运行在服务器端的JavaScript，可以摆脱浏览器宿主环境，解析和执行js代码，直接进行底层系统调用，并且内置提供了HTTP服务器相关的大量API。 <em>npm</em>随node.js一起安装，是一个包管理工具，用来解决node.js代码部署问题。 <em>webpack</em>是前端工程化打包工具，可以处理功能丰富的大型网站所拥有的复杂的js代码、css代码等，解析它们的依赖关系，转换和打包成模块使用，实现自动化管理前端代码。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>从功能上来说，node.js可以开启一个Web服务，给浏览器提供数据去展示，并且接收浏览器提交过来的用户产生的数据，存储到数据库中，方便后面使用。 我们在代码中使用node.js打包好的模块（模块指具有相同功能的代码的集合），然后需要通过npm工具为我们的工程导入模块以便代码在本地调用，npm工具被包装成一个类似命令行的模式提供给开发者使用。除了调用node.js已有的模块，我们还可以在npm上发布自己的模块和调用其他人所发布的模块。 webpack则是运行在npm上的一个任务执行者，可以看作npm为开发者提供的一个功能，和webpack实现类似功能的主流构建工具还有grunt，gulp，browerity等，其中webpack非常适用于管理前端开发代码，它将一切文件模块化，可以方便地帮助我们简化前端复杂繁多的js文件、css文件的调用，使我们的web应用工程化。 有用的资料：<a href="https://webpack.js.org" target="_blank" rel="noopener">webpack官方网站</a></p>
<h1 id="webpack使用"><a href="#webpack使用" class="headerlink" title="webpack使用"></a><em>webpack</em>使用</h1><p>前提：本地环境支持node.js</p>
<h2 id="全局安装webpack"><a href="#全局安装webpack" class="headerlink" title="全局安装webpack"></a>全局安装webpack</h2><p><code>npm install webpack -g</code></p>
<p>全局安装webpack </p>
<p>webpack4，命令行相关的内容都移到 webpack-cli，所以还需要安装 webpack-cli </p>
<p><code>npm install webpack-cli -g</code></p>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p><code>mkdir app</code> </p>
<p>项目文件夹</p>
<p>在项目路径下 </p>
<p><code>npm init –yes</code></p>
<p>创建package.json文件</p>
<p>package.json 是包描述文件，存储着包的信息（包名、版本、项目的依赖项），最好每个项目都要有个 package.json 文件，就像产品说明书。此文件可自己普通文本改名的方式创建，但一般是 npm 命令创建。运行npm init命令会以向导的方式填写包的信息，不想填的话可回车略过。–yes是快速创建，可以跳过信息的填写直接创建，之后想改可以直接到package.json文件中修改。</p>
<h2 id="局部安装webpack"><a href="#局部安装webpack" class="headerlink" title="局部安装webpack"></a>局部安装webpack</h2><p><code>npm install webpack –save-dev</code></p>
<p>为什么全局安装了还要局部安装：<a href="https://www.cnblogs.com/linziwei/p/7786895.html" target="_blank" rel="noopener">npm全局安装和局部文件安装区别</a> 关于–save和-dev可参考：<a href="https://www.limitcode.com/detail/59a15b1a69e95702e0780249.html" target="_blank" rel="noopener">npm –save和–save-dev 傻傻分不清</a> 接下来分别示例打包js文件和非js文件(css)两种使用场景来说明webpack使用的基本步骤</p>
<h2 id="JS文件"><a href="#JS文件" class="headerlink" title="JS文件"></a>JS文件</h2><p>在app目录下创建test.js文件并保存</p>
<p><code>document.write(“it works!”);</code></p>
<p>打包为bundle.js </p>
<p><code>webpack test.js bundle.js</code></p>
<p>注意，如果是高版本的npm，比如我的是5.6.0，需要加-o </p>
<p><code>webpack test.js -o bundle.js</code></p>
<h2 id="CSS文件"><a href="#CSS文件" class="headerlink" title="CSS文件"></a>CSS文件</h2><p>创建style.css文件 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body &#123; background: pink; &#125;</span><br></pre></td></tr></table></figure>

<p>修改test.js文件 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(“!style-loader!css-loader!./style.css”);<span class="comment">//引用style.css文件 document.write(require(“it works!”);</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。 所以如果我们需要在应用中添加 css 文件，就需要使用到 css-loader 和 style-loader，他们做两件不同的事情，css-loader 会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。</p>
</blockquote>
<p>为了使用style-loader和css-loader，同样我们也需要全局安装style-loader和css-loader </p>
<p><code>npm install style-loader css-loader -g</code></p>
<p>再局部安装 </p>
<p><code>npm install style-loader css-loader –save-dev</code></p>
<p>打包</p>
<p><code>webpack test.js -o bundle.js</code></p>
<p>浏览器打开index.html查看效果</p>
<h2 id="配置-webpack-config-js"><a href="#配置-webpack-config-js" class="headerlink" title="配置 webpack.config.js"></a>配置 webpack.config.js</h2><p>如果我们需要打包多个文件，那么在命令行下一个个输入文件名会比较麻烦，所以我们一般通过配置webpack.config.js文件，然后就可以直接使用webpack命令来打包所有文件。 创建webpack.config.js文件 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">	<span class="comment">//指定入口文件 </span></span><br><span class="line">    entry: &#123; <span class="attr">entry</span>: ‘./test.js’ &#125;, </span><br><span class="line">    <span class="comment">//指定出口文件 </span></span><br><span class="line">    output: &#123; <span class="attr">path</span>: __dirname, <span class="attr">filename</span>: ‘test.js’ &#125;, </span><br><span class="line">    <span class="comment">//模块,指定加载器,可配置各种加载器,test里指定加载文件的格式(.css)，loader里指定加载器名称 </span></span><br><span class="line">    <span class="built_in">module</span>:&#123; <span class="attr">rules</span>:[&#123;<span class="attr">test</span>:<span class="regexp">/\.css\$/</span>&#125;, </span><br><span class="line">    loader:”style-loader!css-loader”] </span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>注意，webpack2之后将loaders改为了rules，如果还是写成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loaders:[&#123;<span class="attr">test</span>:<span class="regexp">/\.css\$/</span>&#125;, <span class="attr">loader</span>:”style-loader!css-loader”]</span><br></pre></td></tr></table></figure>

<p>将报错</p>
<p>在指定出口文件中，<code>path:__dirname</code>path指生成的出口文件的统一路径，__dirname表示当前目录。</p>
<p>如果需要生成的文件在别的目录下，可以在文件开始引入模块path</p>
<p><code>const path=require(‘path’);</code></p>
<p>然后就可以使用path.join()方法，这种方法将多个参数字符串合并成一个路径字符串</p>
<p><code>path: path.join(__dirname,’dist’)</code></p>
<p>出口文件会在/app/dist文件夹下，如果没有dist文件夹会自动创建</p>
<p>或者path.resolve()方法，这种方法以程序为根目录，作为起点，根据参数解析出一个绝对路径</p>
<p><code>path: path.resolve(__dirname,’./dist’)</code></p>
<p>关于它们的区别：<a href="https://blog.csdn.net/qq_33745501/article/details/80270708" target="_blank" rel="noopener">path.join()和path.resolve()</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/webpack%E5%85%A5%E9%97%A8/" data-id="ck6lv6a99000074ub6w4md2w2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-使用LEX(flex)和YACC(bison)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/" class="article-date">
  <time datetime="2018-11-14T03:49:00.000Z" itemprop="datePublished">2018-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/">使用LEX(flex)和YACC(bison)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="LEX与YACC介绍"><a href="#LEX与YACC介绍" class="headerlink" title="LEX与YACC介绍"></a><em>LEX</em>与<em>YACC</em>介绍</h1><p>Lex(Lexxical Analyzar)和Yacc(Yet Another Compiler)分别是词法解析器和语法解析器，用目标语言的正则表达式编写Lex代码，经过flex编译可以生成词法分析的C代码，用目标语言的BNF编写Yacc代码，经过bison编译可以生成语法分析的C代码，将词法分析和语法分析的C代码一起编译即可生成目标语言的编译器。 Lex和Yacc原本是Unix/Linux系统下的工具，UnxUtils将他们移植到了 Windows平台。具体安装配置步骤可以参考：<a href="https://blog.csdn.net/XiaoPANGXia/article/details/44132693" target="_blank" rel="noopener">lex和yacc安装配置</a>）。</p>
<h1 id="环境和工具"><a href="#环境和工具" class="headerlink" title="环境和工具"></a>环境和工具</h1><ul>
<li>Windows</li>
<li>lex和yacc</li>
<li>gcc编译器</li>
<li>PowerShell/cmd或IDE+ParserGenerator (推荐直接使用命令行编译，我没用IDE配置过)</li>
</ul>
<h1 id="Lex使用"><a href="#Lex使用" class="headerlink" title="Lex使用"></a>Lex使用</h1><p>一个基本的lex.l程序 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%&#123; #include &#x2F;第一部分&#x2F; %&#125; </span><br><span class="line">&#x2F;第二部分&#x2F; %% </span><br><span class="line">&#x2F;第三部分&#x2F; %% </span><br><span class="line">&#x2F;第四部分&#x2F; </span><br><span class="line">void main() &#123; </span><br><span class="line">    printf(“The first Lex program.\n”);</span><br><span class="line">&#125; </span><br><span class="line">int yywrap(void) &#123;</span><br><span class="line">    return 1; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>保存为lex.l文件 在保存文件目录下打开命令行 </p>
<p><code>flex lex.l</code></p>
<p>会编译生成lex.yy.c文件 编译lex.yy.c </p>
<p><code>lex.yy.c</code></p>
<p>会编译生成a.exe可执行文件 运行a.exe文件即可看到输出。</p>
<h1 id="Lex语法规则"><a href="#Lex语法规则" class="headerlink" title="Lex语法规则"></a>Lex语法规则</h1><p>lex代码被我分为四个部分</p>
<ul>
<li>第一部分 - 定义</li>
</ul>
<p>包含在<code>%{/*第一部分*/%}</code>，这个部分用来发需要用到的头文件、全局变量、函数说明等，这一部分内容会全部一模一样的拷贝到lex.yy.x文件中。</p>
<ul>
<li>第二部分 - 正规定义</li>
</ul>
<p>这部分可以为一些词法规则进行简化定义，方便使用。 如：<code>[A-Za-z]</code>  之后就可以直接用letter代替正则式[A-Za-z]出现</p>
<ul>
<li>第三部分-词法规则</li>
</ul>
<p>这部分为Lex模式匹配，也是lex代码的重点书写部分。列出词法分析器所需要匹配的正则表达式（或其在第二部分定义的简称），及其在匹配到该正规式时需要进行的动作。 如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;printf(“whitespace\n”);&#125;</span><br><span class="line">&#123;printf(“linebreak\n”);&#125; </span><br><span class="line">“int” &#123;printf(“INT\n”)&#125;; </span><br><span class="line">“&#x3D;” &#123;printf(“colon\n”);&#125; </span><br><span class="line">&#123;letter&#125; </span><br><span class="line">&#123;printf(“ID\n”);&#125;</span><br></pre></td></tr></table></figure>

<p>每一行一条规则，规则前半部分时正规式或简称，注意若是匹配字符串则需要用双引号包含，若使用第二部分定义的简称需要用{}包含。后半部分用空格和前半部分用空格隔开，用{}包含，编写匹配到了该词法是程序需要执行的步骤，完全遵照C语言语法，例子中是匹配成功输出相应提示信息。</p>
<ul>
<li>第四部分 - 辅助函数段</li>
</ul>
<p>这一部分也是用C语言语法，内容也会全部原原本本地拷贝lex.yy.c函数中。在使用中我定义了<code>yywrap()</code> 的函数，这是为了兼容flex版本&gt;2.5.4，除了定义该函数，也可以在文件首行写<code>%option noyywrap</code>，否则编译lex.yy.c时会出现<code>undefined reference toyywrap</code>的错误。具体可参考：<a href="https://stackoverflow.com/questions/1811125/undefined-reference-to-yywrap" target="_blank" rel="noopener">Undefined Reference To yywrap - stackoverflow</a> </p>
<h1 id="Yacc使用"><a href="#Yacc使用" class="headerlink" title="Yacc使用"></a>Yacc使用</h1><p>一个基本的yacc.y程序 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%&#123; <span class="meta">#<span class="meta-keyword">include</span> <span class="comment">/*第一部分*/</span> %&#125; </span></span><br><span class="line"><span class="comment">/*第二部分*/</span> %token ID %% </span><br><span class="line"><span class="comment">/*第三部分*/</span> definition: INT ID | ID ; %% </span><br><span class="line"><span class="comment">/*第四部分*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">yyerror</span><span class="params">(<span class="keyword">char</span> * msg)</span> </span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(“\nerror:%s\n”,msg); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译yacc.y文件 <code>bison yacc.y</code> 生成yacc.tab.c文件</p>
<h1 id="Yacc语法"><a href="#Yacc语法" class="headerlink" title="Yacc语法"></a>Yacc语法</h1><p>要生成最终的语法编译器，需要词法分析器的配合，所以yacc的语法结合lex程序一起分析。</p>
<ul>
<li>第一部分</li>
</ul>
<p>与lex相同</p>
<ul>
<li>第二部分</li>
</ul>
<p>说明语法规则中需要用到的所有终结符和定义算符优先级和结合性等。 具体如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%start &#x2F;&#x2F;语法开始符 </span><br><span class="line">%token &#x2F;&#x2F;终结符 </span><br><span class="line">%left &#x2F;&#x2F;左结合性 </span><br><span class="line">%right &#x2F;&#x2F;右结合性 </span><br><span class="line">%nonassoc &#x2F;&#x2F;无结合性 </span><br><span class="line">%type &#x2F;&#x2F;非终结符语义类型 </span><br><span class="line">%union &#x2F;&#x2F;语义值类型说明</span><br></pre></td></tr></table></figure>

<p><code>%start</code> 后接的是上下文无关文法的开始符号，它是一个特殊的非终结符，所有的推导都从这个非终结符开始。如果不说明%start，yacc自动将语法规则部分（第三部分）中第一条语法规则左部的非终结符作为语法开始符。 <code>%token</code>所接的是终结符，也就是词法分析器中匹配的元素，我们首先要在lex.l中的词法匹配中返回终结符的名称，才能在yacc.y中使用这个非终结符。 举个例子 在lex.l第三部分中： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%% [A-Za-z]+ &#123;printf(“ID\n”);return (ID);&#125; %%</span><br></pre></td></tr></table></figure>

<p> 返回名称为ID的终结符 在yacc.y第二部分中： [cc]%token ID 如果有多个非终结符，可以换行，也可以写在同一行<code>%token ID NUM</code> <code>%token ID %token NUM</code>  <code>%left</code> <code>%right</code> <code>%nonassoc</code>后接需要定义优先级的算符，定义在越后排优先级越高，<code>%nonassoc</code>需要对应<code>%prec</code>使用，<code>%prec</code>使用在语法规则中。 举个例子 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*第二部分*&#x2F; %token ID %left ‘+’ ‘-‘ %left ‘*‘ %nonassoc UMINUS %% </span><br><span class="line">&#x2F;*第三部分*&#x2F; term: ‘-‘ term %prec | term ‘*‘ ID | term ‘+’ ID | term ‘-‘ ID ; %%</span><br></pre></td></tr></table></figure>

<p> 就可以定义’<em>‘优先级大于’+’和’-‘，但首项可以带符号’-‘，首项的符号优先级大于因子的算符。 比如1-2\</em>3的计算是1-(2<em>3)，但-1</em>2的计算是(-1)<em>2而不是-(1</em>2)。</p>
<h3 id="区分左结合性和右结合性"><a href="#区分左结合性和右结合性" class="headerlink" title="区分左结合性和右结合性"></a>区分左结合性和右结合性</h3><p>文法1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term : term+factor |factor</span><br></pre></td></tr></table></figure>

<p> 文法2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">term : factor+term |factor</span><br></pre></td></tr></table></figure>

<p>文法1中‘+’是左结合的，文法2中‘+’是右结合的。 文法1中<code>term = ( term + factor1) + factor2</code>是符合的，其中factor1和前一个+号结合，所以该运算符‘+’是左结合的 文法2中<code>term = factor1 + ( factor2 + term)</code>是符合的，其中factor2和后一个+号结合，所以该运算符‘+’是右结合的 除了算符可以定义优先级，我们也可以利用优先级来定义语法的关键字。 比如在S语言中，有var, const, if, while等关键字，它们同样也符合变量的词法定义<code>{A-Za-z}({A-Za-z}|{0-9})*</code>，在语法分析中就会被识别成变量而导致分析错误，但如果把这些关键字的优先级设置为高于变量，这样在语法分析中就会优先被识别为关键字。注意它们应该都是右结合性，原因参考上面写的优先级判别。 如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%right ID %right CONST VAR IF ELSE THEN WHILE DO BEGIN END</span><br></pre></td></tr></table></figure>



<ul>
<li>第三部分</li>
</ul>
<p>这部分写语言的BNF范式，冒号:的左边即BNF范式的左边，冒号右边即BNF范式的右边，多个推导用|分隔，最后要用分号;结尾。每项推导后面也可以用{}包含C代码，作为匹配到该条语法规则后想要程序进行的动作。</p>
<ul>
<li>第四部分</li>
</ul>
<p>与lex相同 值得注意的是yacc自带的一个函数yyerror </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int yyerror(char *msg) &#123; printf(“\nerror:%s\n”,msg); &#125;</span><br></pre></td></tr></table></figure>

<p>可以输出编译测试代码的错误信息。 但是要清醒一点，输出的是测试代码的错误，而不是yacc代码的错误，yacc是语言编译器的编译器，以c语言举例，它编译生成的是gcc，使用gcc编译用c语言写的测试代码，输出的是测试代码的错误信息而不是gcc编译器源码的错误。有段时间我一直测试输出parse error，其实是进行测试的代码段不符合语言的语法，我非常脑子不清楚地改了半天源码= = 测试代码可以用txt文件储存 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">extern</span> FILE* yyin; yyin = fopen(“test.txt”,”r”); </span><br><span class="line">	yyparse(); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在主函数中读取并分析</p>
<h1 id="生成语法分析器"><a href="#生成语法分析器" class="headerlink" title="生成语法分析器"></a>生成语法分析器</h1><p>lex.l需要引用yacc.tab.h头文件，所以还要用bison生成yacc.tab.h头文件<code>yacc -d yacc.y</code>加参数-d会生成yacc.tab.h和yacc.tab.c文件 然后编译lex.l文件生成lex.yy.c文件 <code>flex lex.l</code>编译lex.yy.c和yacc.tab.c文件 g<code>cc lex.yy.c yacc.tab.c</code> 默认生成的可执行文件是a.exe，这个可执行文件就是我们的语法编译器了。</p>
<h1 id="解决文法冲突"><a href="#解决文法冲突" class="headerlink" title="解决文法冲突"></a>解决文法冲突</h1><p>在第一次写复杂如S语言的文法，难免会出现移进/归约冲突、归约/归约冲突，还可能会定义了无用规则等错误，这些错误bison都会在我们编译yacc.y时指出来</p>
<p> 我们可以通过生成yacc.output文件来找到具体是那些文法出了错误 <code>bison -v yacc.y</code> 在yacc.output文件中 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Useless nonterminals: loop_stmt Terminals which are not used: WHILE DO CASE Useless rules: #18 loop_stmt : WHILE condition DO stmt; Conflict in state 42 between rule 31 and token ‘+’ resolved as shift. Conflict in state 42 between rule 31 and token ‘*‘ resolved as shift. Conflict in state 65 between rule 17 and token ELSE resolved as shift. Conflict in state 70 between rule 29 and token ‘+’ resolved as shift. Conflict in state 70 between rule 29 and token ‘*‘ resolved as shift. Conflict in state 71 between rule 30 and token ‘+’ resolved as reduce. Conflict in state 71 between rule 30 and token ‘*‘ resolved as shift. </span><br><span class="line">State 27 contains 1 shift&#x2F;reduce conflict.</span><br><span class="line">State 43 contains 11 reduce&#x2F;reduce conflicts.</span><br></pre></td></tr></table></figure>

<p>先检查无用的非终结符和无用的规则是否忘了在文法中使用，如果不是则要删除。 状态27存在移进/归约错误 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state 27 term ; factor . ‘*‘ term (rule 34) term ; factor . ‘&#x2F;‘ term (rule 35) unary ; factor . (rule 38) ‘*‘ shift, and go to state 54 ‘&#x2F;‘ shift, and go to state 55 ‘*‘ [reduce using rule 38 (unary)] $default reduce using rule 38 (unary)</span><br></pre></td></tr></table></figure>

<p>可以看到识别到’*’时可以移进也可以归约，需要对文法进行更改。 状态43存在移进归约/归约错误，查看同移进/归约，找到相应规则后进行修改。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="S语言的BNF表示"><a href="#S语言的BNF表示" class="headerlink" title="S语言的BNF表示"></a>S语言的BNF表示</h2><p>(1) &lt;程序&gt;→[&lt;常量说明&gt;][&lt;变量说明&gt;]&lt;语句&gt; </p>
<p>(2) &lt;常量说明&gt;→Const &lt;常量定义&gt;{，&lt;常量定义&gt;}； </p>
<p>(3) &lt;常量定义&gt;→&lt;标识符&gt;＝&lt;无符号整数&gt; </p>
<p>(4) &lt;无符号整数&gt;→&lt;数字&gt;{&lt;数字&gt;} </p>
<p>(5) &lt;字母&gt;→a|b|c| … |z </p>
<p>(6) &lt;数字&gt;→0|1|2| … |9 </p>
<p>(7) &lt;标识符&gt;→&lt;字母&gt;{&lt;字母&gt;|&lt;数字&gt;} </p>
<p>(8) &lt;变量说明&gt;→Var &lt;标识符&gt;{，&lt;标识符&gt;}； </p>
<p>(9) &lt;语句&gt;→&lt;赋值语句&gt;|&lt;条件语句&gt;|&lt;当循环语句&gt;|&lt;复合语句&gt;|ε </p>
<p>(10) &lt;赋值语句&gt;→&lt;标识符&gt;＝&lt;表达式&gt;;</p>
<p> (11) &lt;表达式&gt;→[＋|－]&lt;项&gt;{&lt;加法运算符&gt;&lt;项&gt;} </p>
<p>(12) &lt;项&gt;→&lt;因子&gt;{&lt;乘法运算符&gt;&lt;因子&gt;} </p>
<p>(13) &lt;因子&gt;→&lt;标识符&gt;|&lt;无符号整数&gt;|‘(’&lt;表达式&gt;‘)’</p>
<p> (14) &lt;加法运算符&gt;→＋|－</p>
<p> (15) &lt;乘法运算符&gt;→* |／ </p>
<p>(16) &lt;条件语句&gt;→if &lt;条件&gt; then &lt;语句&gt;| if &lt;条件&gt; then &lt;语句&gt; else &lt;语句&gt; </p>
<p>(17) &lt;条件&gt;→&lt;表达式&gt;&lt;关系运算符&gt;&lt;表达式&gt; </p>
<p>(18) &lt;关系运算符&gt;→＝＝|＜＝|＜|＞|＞＝|＜＞ </p>
<p>(19) &lt;当循环语句&gt;→while &lt;条件&gt; do &lt;语句&gt; </p>
<p>(20) &lt;复合语句&gt;→begin &lt;语句&gt;{；&lt;语句&gt;} end 注：产生式中&lt;、&gt;括起的部分表示一个非终结符号，[、]括起的部分表示可 选项，{、}括起的部分表示可重复，符号 | 表示“或”。</p>
<p>一个简单文法的lex.l和yacc.y代码 文法： E→E+T | T T→T*F |F F→( E )</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/" data-id="ck6lmt4b10000hcub8qp540bf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/23/webpack%E5%85%A5%E9%97%A8/">webpack入门</a>
          </li>
        
          <li>
            <a href="/2018/11/14/%E4%BD%BF%E7%94%A8LEX(flex)%E5%92%8CYACC(bison)/">使用LEX(flex)和YACC(bison)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 C2H4<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>